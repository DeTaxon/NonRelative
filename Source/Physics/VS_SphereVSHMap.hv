
PhysCheckSphereVSHMap := !(PhysSphere^ p,PhysHeightMap^ hMap,centf mapPosition) -> int //TODO
{
	fixes := 0
	triC := 0
	tris := u16[32]

	invPos := mapPosition.Inverse()
	pPos := invPos.Apply(p.System.pos)
	tHeight := p.Radius*pPos.w


	hMap.GetTris(pPos,tris&,triC&,0)
	for i : triC
	{
		hV := vec4f
		normal := vec4f
		nowT := hMap.TriangleDistance(pPos,tris[i],hV&,normal&)

		if nowT
		{
			v := hV - p.System.pos
			itH := Distance(p.System.pos,hV)

			// printf("wut %f %f\n",itH,p.Radius)

			if itH < p.Radius*1.1 //and itH > (-p.Radius)
			{
				diff := p.ImpulseV <+> normal
				p.ImpulseV -= normal*(diff*2)
				tmp := mapPosition.Apply(hV) //TODO remove tmp
				//p.System.pos.z = tmp.z + p.Radius
				fixes += 1
			}
		}
	}
	return fixes
}

//CalcTriangleDist := !(PhysHeightMap^ hMap,vec4f pPos, u16 ind) -> float
//{
//	itTri := ref hMap.Triangles[ind]
//	a := hMap.Dots[itTri[0]]
//	b := hMap.Dots[itTri[1]]
//	c := hMap.Dots[itTri[2]]
//
//	mdl := (a + b + c) / 3.0f
//}
