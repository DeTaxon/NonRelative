
TEngine := class extend TGCObject
{
	vInstance := VulkanInstance^
	overlay := VkOverlayContext

	cacheFile := CacheFile^
	shaderCompiler := ShaderCompiler

    this := !() -> void
    {
        shaderCompiler."this"()
    }

	LoadMap := !(StringView charPath) -> vMap^
	{
		return LoadMap(FSGetFile(charPath))
	}
	LoadMap := !(File^ inFile) -> vMap^
	{
		mp := inFile.GetMap()

		js := new Json
		js.ParseString(mp.Get(),mp.Size())

		result = new vMap

		for it, ind : js
		{
			switch ind
			{
			case "props"
				assert(it.IsArray()) //TODO
				for prop : it
				{
					assert(prop.IsRecord()) //TODO
					for propInfo, propInfoInd : prop
					{
						if propInfoInd == "model"
						{
							if propInfo.IsRecord()
							{
								mdl := LoadModel(inFile,propInfo)	
								newProp := CreateProp(mdl)
								result.mapProps.Push(newProp)
							}else if propInfo.IsField()
							{
								//TODO
							}else{
								assert(false) //TODO emit error
							}
						}
					}
				}
			}
		}
	}

	LoadMesh := !(StringView charPath) -> vModel^
	{
		return LoadMesh(FSGetFile(charPath))
	}
	LoadMesh := !(File^ inFile) -> vModel^
	{
		result = new vModel
		result.LoadFile(inFile)
	}


	LoadModel := !(StringView charPath) -> vModel^
	{
		return LoadModel(FSGetFile(charPath))
	}
	LoadModel := !(File^ inFile) -> vModel^
	{
		js := new Json

		mp := inFile.GetMap()

		js.ParseString(mp.Get(),inFile.Size())

		return LoadModel(inFile,js)
	}
	LoadModel := !(File^ inFile,JsonNode^ js) -> vModel^
	{
		result = new vModel
		
		for it,ind  : js
		{
			switch ind
			{
				case "mesh"
					result.LoadFile(inFile.GetFile(it.Value()))
				case "texture"
					result.ReqTexture = LoadTexture(inFile.GetFile(it.Value()))
				case "phys"
					assert(it.IsRecord())
					switch it^[StringSpan("type")&].Value()
					{
					case "hmap"
						hFile := inFile.GetFile(it^[StringSpan("file")&].Value())
						mapFile := RawModel
						mapFile.LoadFromFile(hFile)

						physMap := new PhysHeightMap()
						physMap.CreateDots(mapFile&)
						result.PhysModel = physMap->{PhysCommon^}
					}
				case void
					assert(false)
			}
		}

	}

	CreateProp := !(vModel^ inModel) -> vProp^
	{
		result = new vProp()
		result.itModel = inModel
		result.PhysModel = inModel.PhysModel
		result.modelTextureSet = modelTextureDescriptor.CreateDescriptor()
		vSetTexture(vInstance,result.modelTextureSet,inModel.ReqTexture,gSamplerNearest)
	}


	LoadTexture := !(StringView charPath) -> TVkTexture^
	{
		return LoadTexture(FSGetFile(charPath))
	}
	LoadTexture := !(File^ inFile) -> TVkTexture^
	{
		result = vk.CreateTexture() //TODO
		result.CreateTexture(inFile)
	}

	modelRenderPass := TRenderPass^
	lightRenderPass := TRenderPass^

	modelLayout := TShaderInput^
	modelPersDescriptor := TDescriptorPool^
	modelTextureDescriptor := TDescriptorPool^

	lightLayout := TShaderInput^
	lightTexPool := TDescriptorPool^

	Init := !() -> void
	{
		modelRenderPass = vInstance.CreateRenderPass(![
			TRenderPassFrame(VK_FORMAT_R8G8B8A8_UNORM,	VK_IMAGE_LAYOUT_UNDEFINED,VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL),
			TRenderPassFrame(VK_FORMAT_R32G32B32A32_SFLOAT,	VK_IMAGE_LAYOUT_UNDEFINED,VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL),
			TRenderPassFrame(VK_FORMAT_R32G32B32A32_SFLOAT,	VK_IMAGE_LAYOUT_UNDEFINED,VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL)
		],true)

		gRenderPassModel = modelRenderPass.Get()

		lightRenderPass = vInstance.CreateRenderPass(![
			TRenderPassFrame(vk.SwapImageFormat,	VK_IMAGE_LAYOUT_UNDEFINED,VK_IMAGE_LAYOUT_PRESENT_SRC_KHR),
		],false)
		gRenderPassLight = lightRenderPass.Get()

		modelLayout = modelRenderPass.CreateLayout(![
			VKType(VType_Float,3),
			VKType(VType_Float,3),
			VKType(VType_Float,2)
		],![
			new TUniformSet(),
			new TImageSet(1)
		],![
			new TVertexPushConstant(4*4*4)
		],
		3
		)

		gModelLayout = modelLayout

		vkDescPool := gModelLayout.CreateDescriptorPool(0,1) //only need one for perspective data
		vkPerspSet = vkDescPool.CreateDescriptor()
		modelPersDescriptor = vkDescPool

		modelTextureDescriptor = modelLayout.CreateDescriptorPool(1,100)

		lightLayout = lightRenderPass.CreateLayout(![
			//vertex input
		],![
			new TImageSet(3)
		],![
			new TVertexPushConstant(2*4)
		],
		1
		)

		lightTexPool = lightLayout.CreateDescriptorPool(0,2)
		gGBufferTextureSet = lightTexPool.CreateDescriptor()
		gGMirrorSet = lightTexPool.CreateDescriptor()

		gLightLayout = lightLayout.Get()

		//overlay.Init(lightRenderPass)

		cacheFile = new CacheFile("EngineData.zip")
		shaderCompiler.SetCacheFile(cacheFile)
	}

	
	LoadShader := !(StringView shaderInfo) -> vShader^
	{
		fil := FSGetFile(shaderInfo)
		flMap := fil.GetMap()
		js := new Json
		js.ParseString(flMap.Get()->{char^},flMap.Size())

		shaderType := TShaderInput^

		vertName := StringSpan
		fragName := StringSpan
		for nd, nodeName : js^
		{
			switch nodeName
			{
				case "type"
					switch nd.Value()
					{
						case "light"
							shaderType = lightLayout
						case "model"
							shaderType = modelLayout
						case void
							assert(false) //TODO emit exception
					}
				case "vertex"
					vertName = nd.Value()
				case "fragment"
					fragName = nd.Value()
				case void
					assert(false) //TODO emit exception
			}
		}

		vertBlob := shaderCompiler.Compile(fil.GetFile(vertName))
		fragBlob := shaderCompiler.Compile(fil.GetFile(fragName))

		return shaderType.CreateShader(vertBlob,fragBlob)
	}
}
