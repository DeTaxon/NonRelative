
gRenderPassModel := VkRenderPass
gRenderPassLight := VkRenderPass

depthTexture := TVkTexture^
fbTextures := TVkTexture^[3]

gLightShader := vShader^

gLightLayout := VkPipelineLayout
gGBufferLayoutSets := VkDescriptorPool
gGBufferTextureSet := VkDescriptorSet
gGMirrorSet := VkDescriptorSet

gModelBase2 := VFramebufferBase^
gModel2 := VFramebuffer^
gMirror := VFramebuffer^

gFBW := 2048
gFBH := 2048
CreateFB := !() -> void
{

	//create depth
	depthTexture = vk.CreateTexture()
	depthTexture.CreateObject(gFBW,gFBH,(img,viv)==> {
		img.format = VK_FORMAT_D16_UNORM
		img.usage = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
		viv.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT
	})

	gModelBase2 = CreateFramebufferBase(vk,engine.modelRenderPass,gFBW,gFBH,![
		VK_FORMAT_R8G8B8A8_UNORM,
		VK_FORMAT_R32G32B32A32_SFLOAT,
		VK_FORMAT_R32G32B32A32_SFLOAT
	],true)

	gModel2 = gModelBase2.CreateFrame(null,depthTexture)

	fbTextures[0] = gModel2.Images[0]
	fbTextures[1] = gModel2.Images[1]
	fbTextures[2] = gModel2.Images[2]

	gModel2.ClearValues[0] = 1.0f
	gModel2.ClearValues[1] = 0.5f
	gModel2.ClearValues[2] = 0.0f
	gModel2.ClearValues[3] = 1.0f

	imgI := VkDescriptorImageInfo[3]
	imgI[0].sampler = gSamplerNearest
	imgI[0].imageView = fbTextures[0].View()
	imgI[0].imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
	imgI[1].sampler = gSamplerNearest
	imgI[1].imageView = fbTextures[1].View()
	imgI[1].imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
	imgI[2].sampler = gSamplerNearest
	imgI[2].imageView = fbTextures[2].View()
	imgI[2].imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL

	wrT := VkWriteDescriptorSet()
	wrT.descriptorCount = 3
	wrT.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
	wrT.pImageInfo&->{void^^}^ = imgI[0]&
	wrT.dstSet = gGBufferTextureSet

	vk.Funcs.vkUpdateDescriptorSets(vk.LogicalDevice,1,wrT&,0,null)

	gMirror = gModelBase2.CreateFrame(null,depthTexture)
	fbTextures[0] = gMirror.Images[0]
	fbTextures[1] = gMirror.Images[1]
	fbTextures[2] = gMirror.Images[2]

	gMirror.ClearValues[0] = 0.0f
	gMirror.ClearValues[1] = 0.5f
	gMirror.ClearValues[2] = 1.0f
	gMirror.ClearValues[3] = 1.0f

	imgI[0].imageView = fbTextures[0].View()
	imgI[1].imageView = fbTextures[1].View()
	imgI[2].imageView = fbTextures[2].View()

	wrT.descriptorCount = 3
	wrT.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
	wrT.pImageInfo&->{void^^}^ = imgI[0]&
	wrT.dstSet = gGMirrorSet

	vk.Funcs.vkUpdateDescriptorSets(vk.LogicalDevice,1,wrT&,0,null)
}

DrawGetImage := !() -> bool
{
	vkResetFences(vkLogCard,1,vkFence&)
	resAq := vkAcquireNextImageKHR(vkLogCard,vkSwapchain,not_b 0U,null,vkFence,nowImg&)

	if resAq ==  VK_ERROR_OUT_OF_DATE_KHR or resAq == VK_SUBOPTIMAL_KHR
	{
		return false
	}

	vkWaitForFences(vkLogCard,1,vkFence&,1,10000000)
	return true
}

StartModelDraw := !(VkCommandBuffer cmd) -> bool
{
	gModel2.StartRenderPass(cmd)
	return true
}
StopModelDraw := !(VkCommandBuffer cmd) -> bool
{
	vk.Funcs.vkCmdEndRenderPass(cmd) //TODO remove vk.Funcs
}
StartTextDraw := !(VkCommandBuffer cmd,VkFramebuffer frm, VkImageView img ) -> void
{
	imgBarCPre := VkImageMemoryBarrier[2]

	beginInfo := VkRenderPassBeginInfo()

	clrValues := float[13]

	clrValues[0] = 0.0
	clrValues[1] = 0.5
	clrValues[2] = 1.0
	clrValues[4] = 1.0f
	clrValues[5] = 0.0f
	clrValues[6] = 0.0f
	clrValues[7] = 1.0f

	clrValues[8] = 0.0f
	clrValues[9] = 1.0f
	clrValues[10] = 0.0f
	clrValues[11] = 0.0f

	beginInfo.renderPass = gRenderPassLight
	beginInfo.framebuffer = frm
	beginInfo.renderArea.extent.width = vk.GetSurfaceWidth()
	beginInfo.renderArea.extent.height = vk.GetSurfaceHeight()
	beginInfo.clearValueCount = 1
	beginInfo.pClearValues&->{void^^}^ = clrValues[0]&->{void^}
	
	renderPassAttms := VkRenderPassAttachmentBeginInfo()
	renderPassAttms.attachmentCount = 1
	renderPassAttms.pAttachments = img&
	beginInfo.pNext = renderPassAttms&

	vk.Funcs.vkCmdBeginRenderPass(cmd,beginInfo&,VK_SUBPASS_CONTENTS_INLINE) //TODO remove vk.Funcs

	gLightShader.ApplyShaderToQueue(vk,cmd,vk.GetSurfaceWidth(),vk.GetSurfaceHeight())
	sts := VkDescriptorSet[2]

	if TestMirror
	{
		sts[0] = gGMirrorSet
	}else{
		sts[0] = gGBufferTextureSet
	}
	vk.Funcs.vkCmdBindDescriptorSets(cmd,VK_PIPELINE_BIND_POINT_GRAPHICS,gLightLayout,0,1,sts[0]&,0,null) //TODO remove vk.Funcs

	scales := float[2]
	scales[0] = vk.GetSurfaceWidth() / gFBW
	scales[1] = vk.GetSurfaceHeight() / gFBH
	vk.Funcs.vkCmdPushConstants(cmd,gLightLayout,VK_SHADER_STAGE_VERTEX_BIT,0,4*2,scales&) //TODO remove vk.Funcs

	gQuad.Bind(cmd)
	vk.Funcs.vkCmdDraw(cmd,3,1,0,0) //TODO remove vk.Funcs
}

TestMirror := bool
StopTextDraw := !(VkCommandBuffer cmd) -> bool
{
	vk.Funcs.vkCmdEndRenderPass(cmd) //TODO remove vk.Funcs
}
