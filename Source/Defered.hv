
gRenderPassModel := VkRenderPass
gRenderPassLight := VkRenderPass

gModelFramebuffer := VkFramebuffer

depthTexture := TVkTexture^
fbTextures := TVkTexture^[2]

gLightShader := vShader^

gLightLayout := VkPipelineLayout
gGBufferLayoutSets := VkDescriptorPool
gGBufferTextureSet := VkDescriptorSet

gFBW := 2048
gFBH := 1024
CreateFB := !() -> void
{
	// if depthTexture != null
	// {
	// 	depthTexture.Destroy()
	// 	delete depthTexture
	// 	depthTexture = null
	// }

	fbTextures[0] = vk.CreateTexture() //TODO
	fbTextures[0].CreateObject(gFBW,gFBH, (img,viw) ==> {
		img.usage = VK_IMAGE_USAGE_SAMPLED_BIT or_b VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT or_b VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT
	})
	fbTextures[1] = vk.CreateTexture() //TODO
	fbTextures[1].CreateObject(gFBW,gFBH, (img,viw) ==> {
		img.usage = VK_IMAGE_USAGE_SAMPLED_BIT or_b VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT or_b VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT
		img.format = VK_FORMAT_R32G32B32A32_SFLOAT
	})

	//create deth
	depthTexture = vk.CreateTexture()
	depthTexture.CreateObject(gFBW,gFBH,(img,viv)==> {
		img.format = VK_FORMAT_D16_UNORM
		img.usage = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT
		viv.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT
	})

	extrV := VkImageView[3]
	extrV[0] = fbTextures[0].View()
	extrV[1] = fbTextures[1].View()
	extrV[2] = depthTexture.View()
	fbC := VkFramebufferCreateInfo()
	fbC.renderPass = gRenderPassModel
	fbC.attachmentCount = 3
	fbC.pAttachments&->{void^^}^ = extrV[0]&
	fbC.width = gFBW
	fbC.height = gFBH
	fbC.layers = 1

	vk.Funcs.vkCreateFramebuffer(vk.LogicalDevice,fbC&,null,gModelFramebuffer&)

	imgI := VkDescriptorImageInfo[2]
	imgI[0].sampler = gSamplerNearest
	imgI[0].imageView = fbTextures[0].View()
	imgI[0].imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
	imgI[1].sampler = gSamplerNearest
	imgI[1].imageView = fbTextures[1].View()
	imgI[1].imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL

	wrT := VkWriteDescriptorSet()
	wrT.descriptorCount = 2
	wrT.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
	wrT.pImageInfo&->{void^^}^ = imgI[0]&
	wrT.dstSet = gGBufferTextureSet

	vk.Funcs.vkUpdateDescriptorSets(vk.LogicalDevice,1,wrT&,0,null)
}

DrawGetImage := !() -> bool
{
	vkResetFences(vkLogCard,1,vkFence&)
	resAq := vkAcquireNextImageKHR(vkLogCard,vkSwapchain,not_b 0U,null,vkFence,nowImg&)

	if resAq ==  VK_ERROR_OUT_OF_DATE_KHR or resAq == VK_SUBOPTIMAL_KHR
	{
		//if resAq == VK_SUBOPTIMAL_KHR
		//{
		//	res := VkResult
		//	pI := VkPresentInfoKHR()
		//	pI.pNext = null
		//	pI.waitSemaphoreCount = 0
		//	pI.pWaitSemaphores = null
		//	pI.swapchainCount = 1
		//	pI.pSwapchains&->{void^^}^ = vkSwapchain&->{void^}
		//	pI.pImageIndices&->{void^^}^ = nowImg&->{void^}
		//	pI.pResults&->{void^^}^ = res&

		//	vk.Funcs.vkQueuePresentKHR(vk.DrawQueue,pI&)
		//	vk.Funcs.vkQueueWaitIdle(vk.DrawQueue)
		//}
		return false
	}

	vkWaitForFences(vkLogCard,1,vkFence&,1,10000000)
	return true
}

StartModelDraw := !(VkCommandBuffer cmd) -> bool
{
	clrValues := float[13]

	clrValues[0] = 1.0f
	clrValues[1] = 0.5f
	clrValues[2] = 0.0f
	clrValues[3] = 1.0f

	clrValues[4] = 1.0f
	clrValues[5] = 1.0f
	clrValues[6] = 1.0f
	clrValues[7] = 1.0f

	clrValues[8] = 1.0f
	clrValues[9] = 1.0f
	clrValues[10] = 1.0f
	clrValues[11] = 1.0f

	rpC := VkRenderPassBeginInfo()
	rpC.renderPass = gRenderPassModel
	rpC.framebuffer = gModelFramebuffer
	rpC.renderArea.extent.width = vk.GetSurfaceWidth() //surfAb.currentExtent.width
	rpC.renderArea.extent.height = vk.GetSurfaceHeight() //surfAb.currentExtent.height
	rpC.clearValueCount = 3
	rpC.pClearValues&->{void^^}^ = clrValues[0]&
	
	vk.Funcs.vkCmdBeginRenderPass(cmd,rpC&,VK_SUBPASS_CONTENTS_INLINE) //TODO remove vk.Funcs
	return true
}
StopModelDraw := !(VkCommandBuffer cmd) -> bool
{
	vk.Funcs.vkCmdEndRenderPass(cmd) //TODO remove vk.Funcs
}
StartTextDraw := !(VkCommandBuffer cmd,VkFramebuffer frm ) -> void
{
	imgBarCPre := VkImageMemoryBarrier[2]

	beginInfo := VkRenderPassBeginInfo()

	clrValues := float[13]

	clrValues[0] = 0.0
	clrValues[1] = 0.5
	clrValues[2] = 1.0
	clrValues[4] = 1.0f
	clrValues[5] = 0.0f
	clrValues[6] = 0.0f
	clrValues[7] = 1.0f

	clrValues[8] = 0.0f
	clrValues[9] = 1.0f
	clrValues[10] = 0.0f
	clrValues[11] = 0.0f

	beginInfo.renderPass = gRenderPassLight
	beginInfo.framebuffer = frm
	beginInfo.renderArea.extent.width = vk.GetSurfaceWidth() //surfAb.currentExtent.width
	beginInfo.renderArea.extent.height = vk.GetSurfaceHeight() //surfAb.currentExtent.height
	beginInfo.clearValueCount = 1
	beginInfo.pClearValues&->{void^^}^ = clrValues[0]&->{void^}
	
	vk.Funcs.vkCmdBeginRenderPass(cmd,beginInfo&,VK_SUBPASS_CONTENTS_INLINE) //TODO remove vk.Funcs

	gLightShader.ApplyShaderToQueue(cmd)
	sts := VkDescriptorSet[2]
	sts[0] = gGBufferTextureSet
	vk.Funcs.vkCmdBindDescriptorSets(cmd,VK_PIPELINE_BIND_POINT_GRAPHICS,gLightLayout,0,1,sts[0]&,0,null) //TODO remove vk.Funcs

	scales := float[2]
	scales[0] = vk.GetSurfaceWidth() / gFBW
	scales[1] = vk.GetSurfaceHeight() / gFBH
	vk.Funcs.vkCmdPushConstants(cmd,gLightLayout,VK_SHADER_STAGE_VERTEX_BIT,0,4*2,scales&) //TODO remove vk.Funcs

	gQuad.Bind(cmd)
	vk.Funcs.vkCmdDraw(cmd,3,1,0,0) //TODO remove vk.Funcs
}
StopTextDraw := !(VkCommandBuffer cmd) -> bool
{
	vk.Funcs.vkCmdEndRenderPass(cmd) //TODO remove vk.Funcs
}
