CmdBuffer := class
{
	itCmdBuf := VkCommandBuffer
	itPauseItm := VkSemaphore
	itUseInSecond := bool

	
	CreateBuffer := !() -> void
	{
		CreateBuffer(false)
	}
	CreateBuffer := !(bool isSecond) -> void
	{
		itUseInSecond = isSecond
		cmdBufC := VkCommandBufferAllocateInfo()

		cmdBufC.commandPool = vkCmdPool
		cmdBufC.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY 
		if isSecond
			cmdBufC.level = VK_COMMAND_BUFFER_LEVEL_SECONDARY
		cmdBufC.commandBufferCount = 1
		
		vkAllocateCommandBuffers(vkLogCard,cmdBufC&,itCmdBuf&)

		semInf := VkSemaphoreCreateInfo()
		vkCreateSemaphore(vkLogCard,semInf&,null,itPauseItm&)
	}

	Reset := !() -> void
	{
		vkResetCommandBuffer(itCmdBuf,VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT)
	}

	Get := !() -> VkCommandBuffer
	{
		return itCmdBuf
	}
	Start := !() -> void
	{
		inhC := VkCommandBufferInheritanceInfo()

		inhC.renderPass = gRenderPassModel
		inhC.subpass = 0
		//TODO: WARNING, REMOVE FRAMEBUFFER
		//inhC.framebuffer = vkFramebuffers[nowImg]
		inhC.framebuffer = gModelFramebuffer
		inhC.occlusionQueryEnable = 0
		inhC.queryFlags = 0
		inhC.pipelineStatistics = 0

		biC := VkCommandBufferBeginInfo()
		biC.flags = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT
		if itUseInSecond biC.flags = VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT
		biC.pInheritanceInfo&->{void^^}^ = inhC&->{void^}

		vkBeginCommandBuffer(itCmdBuf,biC&)
	}
	Stop := !() -> void
	{
		vkEndCommandBuffer(itCmdBuf)
	}
	UseSecondary := !(VkCommandBuffer mainCmd) -> void
	{
		vkCmdExecuteCommands(mainCmd,1,this.itCmdBuf&)
	}
	Submit := !() -> void
	{
		waitMsk := VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT
		submInf := VkSubmitInfo()
		submInf.waitSemaphoreCount = 0
		submInf.pWaitSemaphores = null
		submInf.pWaitDstStageMask&->{void^^}^ = waitMsk&->{void^}
		submInf.commandBufferCount = 1
  		submInf.pCommandBuffers = itCmdBuf&
  		submInf.signalSemaphoreCount = 0
  		submInf.pSignalSemaphores = null

		vkQueueSubmit(vkQueue, 1, submInf&, null)
		vkDeviceWaitIdle(vkLogCard)
	}
}
