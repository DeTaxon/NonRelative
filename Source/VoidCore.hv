
gSamplerNearest := VkSampler
gSamplerLinear := VkSampler

gObjectLayoutSets := VkDescriptorPool

VoidCoreInit := !() -> void
{
	vk.initCreateStageMemory()

	poolSize := u32[2] 
	poolSize[0] = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
	poolSize[1] = 100 //TODO: size, add dynamicly

	nPool := VkDescriptorPoolCreateInfo()
	nPool.maxSets = 100
	nPool.poolSizeCount = 1
	nPool.pPoolSizes&->{void^^}^ = poolSize&->{void^}

	vkCreateDescriptorPool(vkLogCard,nPool&,null,gObjectLayoutSets&)

	imV := VkSamplerCreateInfo()
	imV.magFilter = VK_FILTER_NEAREST
	imV.minFilter = VK_FILTER_NEAREST
	imV.mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST
	imV.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE
	imV.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE
	imV.addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE
	//imV.mpLodBias = 0.0f
	//imV.anisotropyEnable = VK_FALSE
	imV.maxAnisotropy = 1.0
	imV.compareEnable = VK_FALSE
	imV.compareOp = VK_COMPARE_OP_ALWAYS
	imV.minLod = 0.0
	imV.maxLod = 0.0
	imV.borderColor = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK
	//imV.unnormalizedCoordinates = VK_FALSE

	vkCreateSampler(vkLogCard,imV&,null,gSamplerNearest&)
	imV.magFilter = VK_FILTER_LINEAR
	imV.minFilter = VK_FILTER_LINEAR
	vkCreateSampler(vkLogCard,imV&,null,gSamplerLinear&)
}

vStageCpyToImage := !(VkImage tCpy,int w, int h) -> void
{
	vk.PushTransferQueueAndWait(cmd ==> {
		stg1 := VkImageMemoryBarrier()

		stg1.srcAccessMask = 0
		stg1.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT
		stg1.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED
		stg1.newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
		stg1.srcQueueFamilyIndex = 0
		stg1.srcQueueFamilyIndex = not_b stg1.srcQueueFamilyIndex
		stg1.dstQueueFamilyIndex = stg1.srcQueueFamilyIndex
		stg1.image = tCpy
		stg1.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT
		stg1.subresourceRange.levelCount = 1
		stg1.subresourceRange.layerCount = 1


		vk.Funcs.vkCmdPipelineBarrier(cmd.Get(),VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
			VK_PIPELINE_STAGE_TRANSFER_BIT,0,0,null,0,null,1,stg1&)

		cpyCmd := VkBufferImageCopy
		cpyCmd.imageSubresource.layerCount = 1
		cpyCmd.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT
		cpyCmd.imageExtent.width = w
		cpyCmd.imageExtent.height = h
		cpyCmd.imageExtent.depth = 1

		vk.Funcs.vkCmdCopyBufferToImage(cmd.Get(),vk.itStageMemory.GetBufferPointer()^,tCpy,VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,1,cpyCmd&)

		stg2 := VkImageMemoryBarrier()
		stg2.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT
		stg2.dstAccessMask = VK_ACCESS_SHADER_READ_BIT
		stg2.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
		stg2.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
		stg2.srcQueueFamilyIndex = 0
		stg2.srcQueueFamilyIndex = not_b stg2.srcQueueFamilyIndex
		stg2.dstQueueFamilyIndex = stg2.srcQueueFamilyIndex
		stg2.image = tCpy
		stg2.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT
		stg2.subresourceRange.levelCount = 1
		stg2.subresourceRange.layerCount = 1

		vk.Funcs.vkCmdPipelineBarrier(cmd.Get(),VK_PIPELINE_STAGE_TRANSFER_BIT,VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,0,0,null,0,null,1,stg2&)
	})
}
vSetTexture := !(VkDescriptorSet toSet,TVkTexture^ donor,VkSampler smSampler) -> void
{
	imgI := VkDescriptorImageInfo
	imgI.sampler = smSampler
	imgI.imageView = donor.itImgView
	imgI.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL

	wrT := VkWriteDescriptorSet()
	wrT.descriptorCount = 1
	wrT.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
	wrT.pImageInfo&->{void^^}^ = imgI&
	wrT.dstSet = toSet

	vk.Funcs.vkUpdateDescriptorSets(vk.LogicalDevice,1,wrT&,0,null)
}
