
gSamplerNearest := VkSampler
gSamplerLinear := VkSampler

gDoubleMem := bool
gObjectLayoutSets := VkDescriptorPool

VoidCoreInit := !() -> void
{

	gDoubleMem = true
	if vkGpuMemId == vkCpuMemId or vkGpuMemId == -1
		gDoubleMem = false

	vk.initCreateStageMemory()

	//gCam."this"()
	//gCam.SetPerspective(gWindowW,gWindowH,0.01f,100.0f,90deg)

	poolSize := u32[2] 
	poolSize[0] = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
	poolSize[1] = 100 //TODO: size, add dynamicly

	nPool := VkDescriptorPoolCreateInfo()
	nPool.maxSets = 100
	nPool.poolSizeCount = 1
	nPool.pPoolSizes&->{void^^}^ = poolSize&->{void^}

	vkCreateDescriptorPool(vkLogCard,nPool&,null,gObjectLayoutSets&)

	imV := VkSamplerCreateInfo()
	imV.magFilter = VK_FILTER_NEAREST
	imV.minFilter = VK_FILTER_NEAREST
	imV.mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST
	imV.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE
	imV.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE
	imV.addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE
	//imV.mpLodBias = 0.0f
	//imV.anisotropyEnable = VK_FALSE
	imV.maxAnisotropy = 1.0
	imV.compareEnable = VK_FALSE
	imV.compareOp = VK_COMPARE_OP_ALWAYS
	imV.minLod = 0.0
	imV.maxLod = 0.0
	imV.borderColor = VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK
	//imV.unnormalizedCoordinates = VK_FALSE

	vkCreateSampler(vkLogCard,imV&,null,gSamplerNearest&)
	imV.magFilter = VK_FILTER_LINEAR
	imV.minFilter = VK_FILTER_LINEAR
	vkCreateSampler(vkLogCard,imV&,null,gSamplerLinear&)
}

vStageCpyToBuffer := !(VkBuffer tCpy,int nSize) -> void
{
	cpyCmd := VkBufferCopy
	cpyCmd.size = nSize
	
	//vkFuncs.vkBeginCommandBuffer(mainCmd.Get(),strtCmd)
	mainCmd.Reset()
	mainCmd.Start()
	vkCmdCopyBuffer(mainCmd.Get(),vk.itStageMemoryBuffer,tCpy,1,cpyCmd&)
	memBar := VkBufferMemoryBarrier()
	memBar.srcAccessMask = VK_ACCESS_MEMORY_WRITE_BIT
	memBar.dstAccessMask = VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT
	memBar.srcQueueFamilyIndex = 0
	memBar.srcQueueFamilyIndex = not_b memBar.srcQueueFamilyIndex
	memBar.dstQueueFamilyIndex = memBar.srcQueueFamilyIndex
	memBar.buffer = tCpy
	memBar.size = nSize

	vkCmdPipelineBarrier(mainCmd.Get(),VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_VERTEX_INPUT_BIT,0,0,null,1,memBar&,0,null)
	mainCmd.Stop()
	mainCmd.Submit()

}
vStageCpyToImage := !(VkImage tCpy,int w, int h) -> void
{
	mainCmd.Reset()
	mainCmd.Start()

	//isr := @temp new VkImageSubresourceRange
	//isr.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT
	//isr.levelCount = 1
	//isr.layerCount = 1

	stg1 := VkImageMemoryBarrier()

	stg1.srcAccessMask = 0
	stg1.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT
	stg1.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED
	stg1.newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
	stg1.srcQueueFamilyIndex = 0
	stg1.srcQueueFamilyIndex = not_b stg1.srcQueueFamilyIndex
	stg1.dstQueueFamilyIndex = stg1.srcQueueFamilyIndex
	stg1.image = tCpy
	stg1.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT
	stg1.subresourceRange.levelCount = 1
	stg1.subresourceRange.layerCount = 1


	vk.Funcs.vkCmdPipelineBarrier(mainCmd.Get(),VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,
		VK_PIPELINE_STAGE_TRANSFER_BIT,0,0,null,0,null,1,stg1&)

	cpyCmd := VkBufferImageCopy
	cpyCmd.imageSubresource.layerCount = 1
	cpyCmd.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT
	cpyCmd.imageExtent.width = w
	cpyCmd.imageExtent.height = h
	cpyCmd.imageExtent.depth = 1

	vk.Funcs.vkCmdCopyBufferToImage(mainCmd.Get(),vk.itStageMemoryBuffer,tCpy,VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,1,cpyCmd&)

	stg2 := VkImageMemoryBarrier()
	stg2.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT
	stg2.dstAccessMask = VK_ACCESS_SHADER_READ_BIT
	stg2.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL
	stg2.newLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL
	stg2.srcQueueFamilyIndex = 0
	stg2.srcQueueFamilyIndex = not_b stg2.srcQueueFamilyIndex
	stg2.dstQueueFamilyIndex = stg2.srcQueueFamilyIndex
	stg2.image = tCpy
	stg2.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT
	stg2.subresourceRange.levelCount = 1
	stg2.subresourceRange.layerCount = 1

	vk.Funcs.vkCmdPipelineBarrier(mainCmd.Get(),VK_PIPELINE_STAGE_TRANSFER_BIT,VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,0,0,null,0,null,1,stg2&)

	mainCmd.Stop()
	mainCmd.Submit()
}
vSetTexture := !(VkDescriptorSet toSet,TVkTexture^ donor,VkSampler smSampler) -> void
{
	imgI := VkDescriptorImageInfo
	imgI.sampler = smSampler
	imgI.imageView = donor.itImgView
	imgI.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL

	wrT := VkWriteDescriptorSet()
	wrT.descriptorCount = 1
	wrT.descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
	wrT.pImageInfo&->{void^^}^ = imgI&
	wrT.dstSet = toSet

	vk.Funcs.vkUpdateDescriptorSets(vk.LogicalDevice,1,wrT&,0,null)
}
