NuklearVulkanContext := class //extend TGCObject
{
	itContext := void^
	vInstance := VulkanInstance^

	atlasData := nk_font_atlas 
	atlasTexture := TVkTexture^

	textList := List.{int}
	renderMesh := TVkMesh^

	Init := !(VulkanInstance^ vi) -> void
	{
		vInstance = vi
		uring_init() //TODO once

		itContext = calloc(nk_context_size(),1)

		ax := 0
		ay := 0
		nk_font_atlas_init_default(atlasData&)
		nk_font_atlas_begin(atlasData&)

		fnt2 := nk_font_atlas_add_default(atlasData&,24,null)

		//ttf := FSGetFile("./Pacifico.ttf")
		//ttfMap := ttf.GetMap()
		//fnt := nk_font_atlas_add_from_memory(atls_data,ttfMap.Get(),ttfMap.Size(),24,null)

		imgABC := nk_font_atlas_bake(atlasData&,ax&,ay&,NK_FONT_ATLAS_RGBA32)

		atlasTexture = vk.CreateTexture()
		atlasTexture.CreateObject(ax,ay)

		tempMem := vk.itStageMemory
		tempMem.TransferData(TArraySpan.{u8}(imgABC->{u8^},ax*ay*4))
		vStageCpyToImage(atlasTexture.itImg,ax,ay) //TODO refactor

		nk_font_atlas_end(atlasData&,atlasTexture,null)

		nk_init_default(itContext,fnt2->{void^^}[1]&)

		nk_style_load_all_cursors(itContext,atlasData.cursors[0]&)
	}

	RenderStep := !() -> void
	{
		layT := nk_draw_vertex_layout_element[4]
		layT[0].attribute = NK_VERTEX_POSITION
		layT[0].format = NK_FORMAT_FLOAT
		layT[0].offset = 0
		layT[1].attribute = NK_VERTEX_TEXCOORD
		layT[1].format = NK_FORMAT_FLOAT
		layT[1].offset = 4*2
		layT[2].attribute = NK_VERTEX_COLOR
		layT[2].format = NK_FORMAT_R8G8B8A8
		layT[2].offset = 4*4
		layT[3].attribute = NK_VERTEX_ATTRIBUTE_COUNT
		layT[3].format = NK_FORMAT_COUNT
		layT[3].offset = 0

		cfg := nk_convert_config
		cfg.vertex_size = 4*4 + 4
		cfg.vertex_layout = layT[0]&
		cfg.vertex_alignment = 4
		cfg.circle_segment_count = 22
		cfg.curve_segment_count = 22
		cfg.arc_segment_count = 22
		cfg.global_alpha = 1.0f
		cfg.shape_AA = 1
		cfg.line_AA = 1

		vBuf := u8[1024]
		iBuf := u8[1024]
		cmds := u8[1024]

		nk_buffer_init_default(cmds[0]&)

		vRealVertBuf := Vector.{u8}(16*1024)
		vRealIndBuf := Vector.{u8}(16*1024)

		nk_buffer_init_fixed(vBuf[0]&,vRealVertBuf.GetPointer(),16*1024)
		nk_buffer_init_fixed(iBuf[0]&,vRealIndBuf.GetPointer(),2048)
		res := nk_convert(nuklearContext,cmds[0]&,vBuf[0]&,iBuf[0]&,cfg&)

		assert(res == 0)

		cmd := nk__draw_begin(nuklearContext,cmds[0]&)->{nk_draw_command^}
		while cmd != null
		{
			printf("step %p %i\n",cmd.texture,cmd.elem_count)
			printf("rect %f %f %f %f\n",cmd.clip_rect.x,cmd.clip_rect.y,cmd.clip_rect.w,cmd.clip_rect.h)
			textList.Push(cmd.elem_count)
			cmd = nk__draw_next(cmd,cmds[0]&,nuklearContext)->{nk_draw_command^}
		}

		renderMesh = vInstance.CreateMesh(vRealVertBuf&,vRealIndBuf&,VKType(VType_UInt16,1))
	}

	drawLayout := TShaderInput^
	textShader := vShader^ 
	
	nuklearPool := TDescriptorPool^ 
	nuklearDescp := VkDescriptorSet
	CreateShader := !(TRenderPass^ pass) -> void
	{
		drawLayout = pass.CreateLayout(![
			VKType(VType_Float,2),
			VKType(VType_Float,2),
			VKType(VType_UInt8,4)
		],![
			new TImageSet(1)
		],![],
		1
		)

		textShader = drawLayout.CreateShader(FSGetFile("text.vert"),FSGetFile("text.frag")) //TODO!!! embedd

		nuklearPool = drawLayout.CreateDescriptorPool(0,100) //TODO unconst
		nuklearDescp = nuklearPool.CreateDescriptor()
		
		vSetTexture(nuklearDescp,atlasTexture,gSamplerNearest)
	}

	Draw := !(VkCommandBuffer cmdB) -> void
	{
		offsets := VkDeviceSize

		textShader.ApplyShaderToQueue(cmdB)

		sts := VkDescriptorSet[1]
		sts[0] = nuklearDescp
		vInstance.Funcs.vkCmdBindDescriptorSets(cmdB,VK_PIPELINE_BIND_POINT_GRAPHICS,drawLayout.Get(),0,1,sts[0]&,0,null)

		renderMesh.Bind(cmdB)

		index_offset := 0
		for it : textList
		{
			vInstance.Funcs.vkCmdDrawIndexed(cmdB,it,1,index_offset,0,0)
			index_offset += it
		}
	}
	
	Destroy := virtual !() -> void
	{
	}
}
