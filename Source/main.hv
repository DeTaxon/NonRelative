win := TestWindow^

gPlayer := PhysPlayer^ 
gCam := vCamera^
gMap := PhysHeightMap^

gQuit := bool

engine := TEngine^

gFpsCounter := int

vkGeometryInstance := class
{
	transform := float[12]
	instanceId_mask := u32
	instanceOffset_flags := u32
	accelerationStructureHandle := u64
}

main := !(char^[] args) -> int
{
	x := 1920
	y := 1080

	//x = 600
	//y = 600

	win = new TestWindow
	win.Init(x,y,"Hi Again",true)
	win.SetInputMode("DISABLED")
	
	//TODO can't create empty class
	engine = new TEngine()

	VulkanInit()
	
	engine.vInstance = vk
	engine.Init()

	VoidCoreInit()
	vk.CreateSwapchain(x,y)
	CreateFB()

	gPlayer = new PhysPlayer()
	gPlayer.System.pos = vec4f(0.0,0.0,2.0,1.0)

	gLightShader = engine.LoadShader("ShadersBin/Defer.json") //TODO only name Defer needed
	learnShader := engine.LoadShader("ShadersBin/LearnShader.json")

	drawMirrorShader := engine.LoadShader("ShadersBin/Mirror.json")

	sphere := engine.LoadModel("Models/Sphere/Sphere.json")

	gCam = new vCamera()
	gCam.SetPerspective(x,y,0.001,100,80deg)

	gPlayerMap = engine.LoadMap("Maps/FirstMap2/FirstMap.json")
	gMapMap := gPlayerMap

	LinkMaps(gPlayerMap,gPlayerMap,45.5x,quantf(0,0,0,1))

	// blsCount := 20
	//
	// for i : blsCount
	// {
	// 	pos := vec4f(RandFloat(2.0,20.0),RandFloat(-1,-20.0),1.2,1.0)
	// 	sphr := engine.CreateProp(sphere)
	// 	sphr.PhysModel.System.pos = pos
	//
	// 	gPlayerMap.mapProps.Push(sphr)
	//
	// 	TSpawnTask(() ==> [ps = RandFloat(1.0,7.0),sphr,pos]{
	// 		while not gQuit
	// 		{
	// 			TSleep(ps)
	// 			sphr.PhysModel.ImpulseV = vec4f(0,0,0.0,0)
	// 			sphr.PhysModel.System.pos = pos
	// 		}
	// 	})
	// }


	hdn := engine.CreateProp(sphere)


	CreateQuad()

	TSpawnTask(() ==> {
		oldTime := GetSteadyTime()
		while not gQuit
		{
			nowTime := GetSteadyTime()
			vPhysStage(nowTime - oldTime)
			oldTime = nowTime
			TSleep(1 / 150)
		}
	})


	lastFpsCheck := GetSteadyTime()
	localFpsCounter := 0

	gCam.camPos.z = 1.7

	step1Cmd := TVkCommandBuffer(vk,vk.itDrawCmdPool2)
	step2Cmd := TVkCommandBuffer(vk,vk.itDrawCmdPool2)


	oldTime := GetSteadyTime()
	inputCoef := 0.5
	while not gQuit
	{
		nowTime := GetSteadyTime()
		delta := nowTime - oldTime
		oldTime = nowTime

		gCam.InputCheck(win,delta*inputCoef,not win.menuMode)
	
		surfaceIndex := u32
		drawRes := false
		@work vk.DrawGetImage(surfaceIndex&,drawRes&)

		localFpsCounter += 1

		if nowTime - lastFpsCheck > 1.0
		{
			lastFpsCheck = nowTime
			gFpsCounter = localFpsCounter
			localFpsCounter = 0
		}

		if drawRes
		{
			{
				step1Cmd.Reset()
				step1Cmd.Start()


				for i : 3
				{
					bar1 := VkImageMemoryBarrier()
					bar1.image = fbTextures[i].Img()
					bar1.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED
					bar1.newLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL
					bar1.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT
					bar1.subresourceRange.levelCount = 1
					bar1.subresourceRange.layerCount = 1
					vk.Funcs.vkCmdPipelineBarrier(step1Cmd.Get(),VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,0,0,null,0,null,1,bar1&)
				}

				{
					bar1 := VkImageMemoryBarrier()
					bar1.image = depthTexture.Img()
					bar1.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED
					bar1.newLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL
					bar1.subresourceRange.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT
					bar1.subresourceRange.levelCount = 1
					bar1.subresourceRange.layerCount = 1
					vk.Funcs.vkCmdPipelineBarrier(step1Cmd.Get(),VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT,VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,0,0,null,0,null,1,bar1&)
				}


				StartModelDraw(step1Cmd.Get())

				gCam.camPos.x = gPlayer.System.pos.x
				gCam.camPos.y = gPlayer.System.pos.y
				gCam.camPos.z = gPlayer.System.pos.z + 1.7


				learnShader.ApplyShaderToQueue(vk,step1Cmd.Get(),vk.GetSurfaceWidth(),vk.GetSurfaceHeight())
				gCam.BindDescriptor(step1Cmd.Get())

				// DebugDrawPoints(step1Cmd.Get(),gCam,hdn)
				DrawMap(step1Cmd.Get(),gPlayerMap,centf(),4)

				StopModelDraw(step1Cmd.Get())
			}


			{

				StartTextDraw(step1Cmd.Get(),vk.surfaceImageViews^[surfaceIndex],surfaceIndex)

				StopTextDraw(step1Cmd.Get())

				{
					bar1 := VkImageMemoryBarrier()
					bar1.image = vk.surfaceImages^[surfaceIndex]
					bar1.oldLayout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL
					bar1.newLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR
					bar1.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT
					bar1.subresourceRange.levelCount = 1
					bar1.subresourceRange.layerCount = 1
					vk.Funcs.vkCmdPipelineBarrier(step1Cmd.Get(),VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT,VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT,0,0,null,0,null,1,bar1&)
				}

				step1Cmd.Stop()
				//vk.Funcs.vkResetFences(vk.LogicalDevice,1,vk.itGlobFence&)
				//step1Cmd.Submit(vk.DrawQueue,vk.itGlobFence)
				step1Cmd.Submit(vk.DrawQueue,null)

				//hm := u64 //TODO
				//hm = not_b hm
				//@work vk.Funcs.vkWaitForFences(vk.LogicalDevice,1,vk.itGlobFence&,0,hm)
			}

			vk.DrawPresentImage(surfaceIndex)
		}
		//win.SwapBuffers()
		win.PollEvents()
		TaskYield()

		if not drawRes
		{
			while not win.ShouldClose()
			{
				win.PollEvents()

				if GetSteadyTime() - win.LastTimeResized > 0.1
				{
					break
				}else{
					TSleep(0.01)
				}
			}

			surfaceInfo := VkSurfaceCapabilitiesKHR
			vk.Funcs.vkGetPhysicalDeviceSurfaceCapabilitiesKHR(vk.PhysicalDevice,vk.itSurface,surfaceInfo&)

			setW := clamp(surfaceInfo.minImageExtent.width,win.Width->{u32},surfaceInfo.minImageExtent.width)
			setH := clamp(surfaceInfo.minImageExtent.height,win.Height->{u32},surfaceInfo.minImageExtent.height)

			//TODO cases when one of values is zero
			while not vk.CreateSwapchain(engine.lightRenderPass,setW,setH)
			{
				TSleep(0.5)
			}
			gCam.UpdatePerspective(win.Width,win.Height)
		}

		if win.ShouldClose() or buttons['Q']
		{
			gQuit = true
		}
	}

	CurrentThread.SkipTimers()
}

