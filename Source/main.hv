
LoadShaderModule := !(char^ name) -> vShaderModule^
{
	fil := FSGetFile(name)
	filMap := fil.GetMap()

	result = new vShaderModule
	result.LoadShaderModule(filMap.Get(),filMap.Size())
}

win := TestWindow^

gPlayer := PhysPlayer^ 
gCam := vCamera^
gMap := PhysHeightMap^

gQuit := bool

engine := TEngine^

gFpsCounter := int

main := !(char^[] args) -> int
{
	x := 1800
	y := 1000

	win = new TestWindow
	win.Init(x,y,"Hi Again")
	win.SetInputMode("DISABLED")
	
	//TODO can't create empty class
	engine = new TEngine

	VulkanInit()
	
	engine.vInstance = vk
	engine.Init()

	VoidCoreInit()
	vk.CreateSwapchain(x,y)
	CreateFB()

	gPlayer = new PhysPlayer()
	gPlayer.System.pos = vec4f(0.0,0.0,2.0,1.0)

	gLightShader = engine.LoadShader("Shaders/Defer.json") //TODO only name Defer needed
	learnShader := engine.LoadShader("Shaders/LearnShader.json")

	canvas := engine.LoadModel("Models/Canvas/Canvas.json")

	gCam = new vCamera()
	gCam.SetPerspective(x,y,0.001,100,80deg)

	canvasProp = engine.CreateProp(canvas)

	canvasProp.propPosition.pos = vec4f(2.0,0.0,1.4,1.0)
	canvasProp.propPosition.ang = quantfAt(0.0,0.0,1.0,-90deg) <*> quantfAt(1.0,0.0,0.0,90deg)

	gPlayerMap = engine.LoadMap("Maps/FirstMap2/FirstMap.json")
	gMapMap := gPlayerMap

	LinkMaps(gPlayerMap,gPlayerMap,45.5x,quantf(0,0,0,1))

	gMapMap.mapProps.Push(canvasProp)

	NuklearTestInit()
	NuklearCreateStep()

	CreateQuad()


	TSpawnTask(() ==> {
		oldTime := GetSteadyTime()
		while not gQuit
		{
			nowTime := GetSteadyTime()
			vPhysStage(nowTime - oldTime)
			oldTime = nowTime
			TSleep(1 / 30)
		}
	})

	lastFpsCheck := GetSteadyTime()
	localFpsCounter := 0

	step1Cmd := TVkCommandBuffer(vk,vk.itDrawCommandPool)
	step2Cmd := TVkCommandBuffer(vk,vk.itDrawCommandPool)

	oldTime := GetSteadyTime()
	inputCoef := 0.5
	while not gQuit
	{
		nowTime := GetSteadyTime()
		delta := nowTime - oldTime
		oldTime = nowTime

		gCam.InputCheck(win,delta*inputCoef,not win.menuMode)

		surfaceIndex := u32
		drawRes := true
		@work vk.DrawGetImage(surfaceIndex&,drawRes&)

		localFpsCounter += 1

		if nowTime - lastFpsCheck > 1.0
		{
			lastFpsCheck = nowTime
			gFpsCounter = localFpsCounter
			localFpsCounter = 0
		}

		if drawRes
		{
			{
				step1Cmd.Reset()
				step1Cmd.Start()

				StartModelDraw(step1Cmd.Get())

				gCam.camPos.x = gPlayer.System.pos.x
				gCam.camPos.y = gPlayer.System.pos.y
				gCam.camPos.z = gPlayer.System.pos.z + 1.7

				learnShader.ApplyShaderToQueue(step1Cmd.Get())
				gCam.BindDescriptor(step1Cmd.Get())

				DrawMap(step1Cmd.Get(),gPlayerMap,centf(),4)
				StopModelDraw(step1Cmd.Get())

				step1Cmd.Stop()
				step1Cmd.Submit(vk.DrawQueue,null)
			}

			{

				step2Cmd.Reset()
				step2Cmd.Start()


				StartTextDraw(step2Cmd.Get(),vk.GetSurfaceFramebuffer(surfaceIndex))

				if win.menuMode
				{
					nuklearC.InputCheck(win)
					nuklearC.MakeDraw()
					nuklearC.RenderStep()
					nuklearC.Clear()

					NuklearDrawStep(step2Cmd.Get(),vk.GetSurfaceWidth(),vk.GetSurfaceHeight())
				}
				StopTextDraw(step2Cmd.Get())

				step2Cmd.Stop()
				vk.Funcs.vkResetFences(vk.LogicalDevice,1,vk.itGlobFence&)
				step2Cmd.Submit(vk.DrawQueue,vk.itGlobFence)

				hm := u64 //TODO
				hm = not_b hm
				@work vk.Funcs.vkWaitForFences(vk.LogicalDevice,1,vk.itGlobFence&,0,hm)
			}

			vk.DrawPresentImage(surfaceIndex)
		}

		win.SwapBuffers()
		win.PollEvents()

		if not drawRes
		{
			//TODO cases when one of values is zero
			vk.CreateSwapchain(win.Width,win.Height)
			gCam.UpdatePerspective(win.Width,win.Height)
		}

		if win.ShouldClose() or buttons['Q']
		{
			exit(0)
			gQuit = true
		}
	}
}

