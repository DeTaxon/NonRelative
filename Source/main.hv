
LoadShaderModule := !(char^ name) -> vShaderModule^
{
	fil := FSGetFile(name)
	filMap := fil.GetMap()

	result = new vShaderModule
	result.LoadShaderModule(filMap.Get(),filMap.Size())
}

gPlayer := PhysPlayer^ 
gCam := vCamera^
gMap := PhysHeightMap^

gQuit := bool

engine := TEngine^

nuklearContext := void^

main := !(char^[] args) -> int
{
	uring_init()

	fb := calloc(1024*1024*4,1)
	texMem := calloc(512*512*4,1)
	defContext := calloc(1024,1)->{u8^}
	nuklearContext = calloc(1,nk_context_size())
	//nk_init_default(nuklearContext,null)
	rawCntx := nk_rawfb_init(fb,texMem,512,512,512*4,0)
	nuklearContext = rawCntx

	atls_data := calloc(1,nk_atlas_size())

	ax := 512
	ay := 512
	nk_font_atlas_init_default(atls_data)
	nk_font_atlas_begin(atls_data)

	fnt2 := nk_font_atlas_add_default(atls_data,24,null)

	// ttf := gRepo.GetFile("./Pacifico.ttf")
	// ttfMap := ttf.GetMap()
	// fnt := nk_font_atlas_add_from_memory(atls_data,ttfMap.Get(),ttfMap.Size(),24,null)

	imgABC := nk_font_atlas_bake(atls_data,ax&,ay&,NK_FONT_ATLAS_RGBA32)
	//imgABC := nk_font_atlas_bake(atls_data,ax&,ay&,0)
	nk_font_atlas_end(atls_data,null,null)


	rect := nk_rect//(10,10,100,100)
	rect.x = 100
	rect.y = 100
	rect.w = 250
	rect.h = 250
	if nk_begin(nuklearContext,"HI",rect,NK_WINDOW_MOVABLE + NK_WINDOW_BORDER + NK_WINDOW_CLOSABLE) != 0
	{
		nk_style_set_font(nuklearContext,fnt2->{void^^}[1]&)
		nk_label(nuklearContext,"test",0x11)
	}
	nk_end(nuklearContext)

	x := 1200
	y := 900
	
	//TODO can't create empty class
	engine = new TEngine

	CreateWindow(x,y)
	VulkanInit()
	VoidCoreInit()
	CreateSwapchain(x,y)
	CreateFB()

	engine.vInstance = vk

	gPlayer = new PhysPlayer()
	gPlayer.System.pos = vec4f(0.0,0.0,2.0,1.0)

	deferVert := LoadShaderModule("Shaders/ShaderCache/Defer.vert")
	deferFrag := LoadShaderModule("Shaders/ShaderCache/Defer.frag")
	gLightShader = new vShader
	gLightShader.LoadShaderLight(deferVert,deferFrag)

	// learnVert := LoadShaderModule("Shaders/ShaderCache/LearnVert.vert")
	learnVert := LoadShaderModule("Vert2.vert")
	learnFrag := LoadShaderModule("Shaders/ShaderCache/LearnFrag.frag")
	learnShader := new vShader
	opts := vShaderVertexOptions
	opts.positionType = VKType(VType_Float,3)
	opts.normalType = VKType(VType_Float,3)
	opts.textureType = VKType(VType_Float,2)
	learnShader.LoadShader(learnVert,learnFrag,opts&)

	canvas := engine.LoadModel("Models/Canvas/Canvas.json")

	gCam = new vCamera()
	gCam.SetPerspective(x,y,0.001,100,80deg)

	newProp := engine.CreateProp(canvas)

	newProp.propPosition.pos = vec4f(2.0,0.0,1.4,1.0)
	newProp.propPosition.ang = quantfAt(0.0,0.0,1.0,-90deg) <*> quantfAt(1.0,0.0,0.0,90deg)

	gPlayerMap = engine.LoadMap("Maps/FirstMap2/FirstMap.json")
	gMapMap := gPlayerMap

	LinkMaps(gPlayerMap,gPlayerMap,45.5x,quantf(0,0,0,1))

	gMapMap.mapProps.Push(newProp)
	
	tempMem := vk.itStageMemory

	clr := nk_color
	nk_rawfb_render(rawCntx,clr,0)
	tempMem.TransferData(TArraySpan.{u8}(fb->{u8^},512*512*4))
	vStageCpyToImage(canvas.ReqTexture.itImg,512,512)


	TSpawnTask(() ==> {
		oldTime := GetSteadyTime()
		while not gQuit
		{
			nowTime := GetSteadyTime()
			vPhysStage(nowTime - oldTime)
			oldTime = nowTime
			TSleep(1 / 30)
		}
	})

	oldTime := GetSteadyTime()
	inputCoef := 0.5
	while not gQuit
	{
		nowTime := GetSteadyTime()
		delta := nowTime - oldTime
		oldTime = nowTime

		//gCam.InputCheck(delta*inputCoef)

		@work DrawGetImage()

		vk.PushDrawQueueAndWait(cmd ==> {
			StartDraw(cmd.Get())

			gCam.camPos.x = gPlayer.System.pos.x
			gCam.camPos.y = gPlayer.System.pos.y
			gCam.camPos.z = gPlayer.System.pos.z + 1.7

			learnShader.ApplyShaderToQueue(cmd.Get())
			gCam.BindDescriptor(cmd.Get())

			DrawMap(cmd.Get(),gPlayerMap,centf(),4)

			StopDraw(cmd.Get())
		})

		res := VkResult
		pI := VkPresentInfoKHR()
		pI.pNext = null
		pI.waitSemaphoreCount = 0
		pI.pWaitSemaphores = null
		pI.swapchainCount = 1
		pI.pSwapchains&->{void^^}^ = vkSwapchain&->{void^}
		pI.pImageIndices&->{void^^}^ = nowImg&->{void^}
		pI.pResults&->{void^^}^ = res&

		vk.Funcs.vkQueuePresentKHR(vk.DrawQueue,pI&)
		vk.Funcs.vkQueueWaitIdle(vk.DrawQueue)
		
		glfwSwapBuffers(glfwWindow)
		glfwPollEvents()

		if glfwWindowShouldClose(glfwWindow) or buttons['Q']
		{
			gQuit = true
		}
	}
}

