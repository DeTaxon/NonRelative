//st_mode 24 size = 144
DirectoryIterator := class
{
	toUse := Path^
	dirFd := void^
	nowPath := Path
	nowBuff := char[1024]
	bufSize := int
	this := !(Path^ tu) -> void
	{
		dirFd = prvtStartFolderIter(tu.itStr,gMallocTemporary)
		bufSize = strlen(tu.itStr)
		memcpy(nowBuff[0]&,tu.itStr,bufSize )
		nowBuff[bufSize] = '/'
		
		nowPath.itStr = nowBuff[0]&
		itmName := prvtGetFolderIterItem(dirFd,gMallocTemporary)
		itmSize := strlen(itmName)
		newSize := nowBuff[bufSize+1]&
		memcpy(newSize,itmName,itmSize)
		newSize[itmSize] = 0
	}

	"^" := !() -> ref Path
	{
		return nowPath
	}
	Inc := !() -> void
	{
		prvtGetNextFolderIter(dirFd)
		itmName := prvtGetFolderIterItem(dirFd,gMallocTemporary)

		if itmName != null
		{
			itmSize := strlen(itmName)
			newSize := nowBuff[bufSize+1]&
			memcpy(newSize,itmName,itmSize)
			newSize[itmSize] = 0
		}
	}
	IsEnd := !() -> bool
	{
		return prvtIsEndFolderIter(dirFd) == 1
	}
}

DirectoryWildcardIterator := class
{
	dirFd := void^
	nowEntry := void^
	nowPath := Path
	buff := char[256]
	addToBuff := int
	wildCard := char[80]
	this := !(char^ tu) -> void
	{
		strL := strlen(tu)

		for c,u : tu
		{
			buff[u] = c
		}
		buff[strL] = 0

		dirL := strL - 1

		while dirL >= 0
		{
			if buff[dirL] in "/\\"
				break
			dirL--
		}
		dirL++

		for i,j : dirL..(strL-1)
		{
			wildCard[j] = buff[i]
			buff[i] = 0
		}
		addToBuff = dirL
		if dirL == 0
		{
			buff[0] = '.'
			buff[1] = '/'
			buff[2] = 0
			addToBuff = 2
		}

		wildCard[strL - dirL] = 0

		dirFd = opendir(buff[0]&)
		Inc()
		nowPath.itStr = buff[0]&
	}
	"~this" := !() -> void
	{
		if dirFd != null closedir(dirFd)
	}
	"^" := !() -> ref Path
	{
		return nowPath
	}
	Inc := !() -> void
	{
		nowEntry = readdir(dirFd)
		while nowEntry != null
		{
			newName := GetDirectoryName(nowEntry)

			if not IsInWildcard(newName)
			{
				nowEntry = readdir(dirFd)
				continue
			}

			preSet := this.addToBuff
			for c : newName
			{
				buff[preSet] = c
				preSet++
			}
			buff[preSet] = 0

			break

		}
	}
	IsInWildcard := !(char^ str) -> bool
	{
		return CmpNameAndWildcard(str,wildCard[0]&)
	}
	IsEnd := !() -> bool
	{
		return nowEntry == null
	}
}


Path := class
{
	itStr := string
	this := !() -> void
	{
		itStr = null
	}
	this := !(string st) -> void
	{
		itStr = st
	}
	this := !(Path st) -> void
	{
		itStr = st.itStr
	}
	Get := !() -> char^
	{
		return itStr
	}
	"==" := !(Path pt2) -> bool
	{
		idX := GetId()
		idY := pt2.GetId()
		if idX == 0 return false
		return idX == idY
	}
	IsExist := !() -> bool
	{
		return GetId() != 0
	}

	FullPath := !() -> Path
	{
		asW := Utf8ToUtf16(itStr)
		preRetW := new u16[MAX_PATH] ; $temp
		retSize := GetFullPathNameW(asW,MAX_PATH,preRetW,null)
		preRetW[retSize] = 0
		return Path(Utf16ToUtf8(preRetW))
	}
	"~For" := !() -> DirectoryIterator
	{
		return DirectoryIterator(this&)
	}
	IsFolder := !() -> bool
	{
		asW := Utf8ToUtf16(itStr)
		return (GetFileAttributesW(asW) and_b FILE_ATTRIBUTE_DIRECTORY) != 0
	}
	"=" := !(Path pt) -> void
	{
		itStr = pt.itStr
	}
	"=" := !(string pt) -> void
	{
		itStr = pt
	}
	"/=" := !(string str) -> void
	{
		itStr = itStr + "/" + str
	}
	"/" := !(string pt2) -> Path
	{
		ToRet.itStr = this.itStr + "/" + pt2
	}
	"/" := !(Path pt2) -> Path
	{
		return Path(itStr + "/" + pt2.itStr)
	}
	Ext := !() -> StringSpan
	{
		size := StrSize(itStr)
		pos := size - 1
		if size == 0 return StringSpan("",0)

		while pos >= 0 and itStr[pos] != '.' {
			if itStr[pos] in "/\\"  return StringSpan("",0)
			pos--
		}
		if pos < 0 return StringSpan("",0)

		return StringSpan(itStr[pos]&, size - pos)
	}
	GetId := !() -> u64
	{
		itAsW := Utf8ToUtf16(itStr)
		hndl := CreateFileW(itAsW,0,FILE_SHARE_READ or_b FILE_SHARE_WRITE or_b FILE_SHARE_DELETE,null,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,null)
		if hndl&->{u64^}^ == not_b 0U
			return 0
		flInf := BY_HANDLE_FILE_INFORMATION
		GetFileInformationByHandle(hndl,flInf&)
		preRes := u64
		preRes = flInf.nFileIndexHigh
		preRes = preRes << 32
		preRes = flInf.nFileIndexLow
		return preRes
	}
	Name := !() -> StringSpan
	{
		size := StrSize(itStr)
		pos := size - 1
		if size == 0 return StringSpan("",0)

		while pos >= 0 {
			if itStr[pos] in "/\\"  break
			pos--
		}
		if pos < 0 return StringSpan("",0)
		if size - pos == 1 return StringSpan("",0)

		return StringSpan(itStr[pos + 1]&, size - pos - 1)
	}
	Size := !() -> u64
	{
		itAsW := Utf8ToUtf16(itStr)
		hndl := CreateFileW(itAsW,0,FILE_SHARE_READ or_b FILE_SHARE_WRITE or_b FILE_SHARE_DELETE,null,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,null)
		if hndl&->{u64^}^ == not_b 0U
			return 0
		flInf := BY_HANDLE_FILE_INFORMATION
		GetFileInformationByHandle(hndl,flInf&)
		preRes := u64
		preRes = flInf.nFileSizeHigh
		preRes = preRes << 32
		preRes = flInf.nFileSizeLow
		return preRes
	}
	FolderName := !() -> string
	{
		size := StrSize(itStr)
		pos := size - 1
		if size == 0 return ""

		while pos >= 0 {
			if itStr[pos] in "/\\"  break
			pos--
		}
		if pos < 0 return ""
		if size - pos == 1 return ""
		pos++
		newStr :=  malloc(pos + 1)->{char^}

		for i : pos newStr[i] = itStr[i]
		newStr[pos] = 0

		return newStr
	}
	JustName := !() -> StringSpan
	{
		itName := this.Name()
		if itName == "" return StringSpan("",0)
		
		itSize := itName.Size()
		pos := itSize - 1

		while pos >= 0 and itName[pos] != '.' pos--

		if pos < 0 return itName
		return StringSpan(itName.Get(),pos)
	}
}
